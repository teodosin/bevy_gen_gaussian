# 2025-08-26 — GenGaussianPlugin investigation notes

Purpose: capture what I inspected and the concrete issues blocking GPU mesh→gaussian conversion so we don’t re‑discover them.

## Files reviewed (do not re-open unless changed)

- bevy_gen_gaussian
	- `src/lib.rs` — registers `GaussianSplattingPlugin` and adds `gaussian::GpuMeshToGaussiansPlugin`.
	- `src/gaussian/gpu_mesh_to_gaussians.rs` — WIP plugin actually wired into `App`; creates cloud on Added<MeshToGaussian>, sets up compute pipeline, but does not dispatch; queries wrong components.
	- `src/gpu_mesh_to_gaussians.rs` — alternate/older implementation not used by lib.rs; references non-existent resources like `GpuPlanarGaussians` and `GpuMeshes`. Keep out of the runtime path or delete later.
	- `assets/shaders/tri_to_splat.wgsl` — triangle→splat kernel (expects positions: array<vec3<f32>>, indices: array<u32> and writes directly into planar buffers).
	- `src/gaussian/cpu_mesh_to_gaussians.rs` — CPU path utility; good reference for triangle enumeration and scale/orientation.
- bevy_gaussian_splatting (renderer we integrate with)
	- `src/lib.rs` — adds Planar storage plugins and render pipeline; confirms we should use Planar3D format (buffer_storage feature).
	- `src/gaussian/formats/planar_3d.rs` — defines `Gaussian3d` + `PlanarGaussian3d` with StorageBindings; default(0) visibility/opacity.
	- `src/render/mod.rs` — shows render schedule, bind groups, draw path; uses `RenderAssets<R::GpuPlanarType>` and inserts a `PlanarStorageBindGroup<R>` on entities for rendering; defines cloud bind group layout at group(2).
	- `src/render/bindings.wgsl` and `src/render/planar.wgsl` — binding indices for planar storage buffers used by renderer.
	- `examples/mesh_to_cloud_cpu.rs` — CPU example for creating and displaying clouds.
- bevy (engine)
	- Looked at PBR render mesh code to verify GPU mesh access patterns; it doesn’t expose a simple “positions-only SSBO”; vertex buffer is interleaved and not directly consumable by our WGSL kernel.

## What’s wrong right now (root causes)

1) System never triggers on the GLTF scene entity
	 - Example `examples/gpu_one_to_one.rs` spawns an entity with `SceneRoot(scene)` and adds `MeshToGaussian` there (on the scene root).
	 - Current conversion system in `gaussian/gpu_mesh_to_gaussians.rs` queries `(Entity, &Mesh3d, &MeshToGaussian, &GlobalTransform), Added<MeshToGaussian>` — requiring `Mesh3d` on the same entity. GLTF meshes live on child entities, so this query finds nothing. Hence:
		 - No `PlanarGaussian3d` asset is spawned for the mesh.
		 - `Visibility::Hidden` isn’t applied (so the original mesh stays visible).

2) Even if the system ran, the cloud would render invisible by default
	 - It builds `vec![Gaussian3d::default(); tri_count]` then `PlanarGaussian3d::from(...)`.
	 - Default `Gaussian3d` has visibility=0 and opacity=0 (zero SH), so the cloud draws nothing until we write into buffers.

3) Compute dispatch doesn’t happen (no encoder/context in a render system)
	 - The code builds a compute pipeline but never validly dispatches. In Bevy 0.16, you can’t start a compute pass from a regular render system; you need a RenderGraph `Node` (with `RenderContext`) or a custom render command that runs before sorting/draw.
	 - Current WIP `queue_tri_to_splat_bind_groups` only logs; no pass submission.

4) Wrong idea for vertex inputs: using Bevy’s GPU vertex buffer directly
	 - Attempted to bind `gpu_mesh.vertex_buffer` as a `array<vec3<f32>> positions` SSBO. That buffer is interleaved vertex attributes (format depends on mesh layout), not a plain `vec3<f32>` array. The WGSL kernel would read garbage.
	 - Fix: build our own SSBOs for `positions: array<vec3<f32>>` and `indices: array<u32>` (upload from CPU once for one‑shot path; for realtime we can stream or skin).

5) Binding to cloud outputs: correct source to use
	 - To write into renderer-owned planar buffers, access the GPU cloud via `RenderAssets<R::GpuPlanarType>` (where R=Gaussian3d Planar). The generated GPU type exposes the storage buffers (position_visibility, rotation, scale_opacity, spherical_harmonics).
	 - We don’t need a custom `PlanarStorageBindGroup` for our compute; we just bind those buffers directly alongside our inputs + uniforms.

6) Duplicate plugin file causes confusion
	 - `src/gaussian/gpu_mesh_to_gaussians.rs` is the one wired in. The sibling `src/gpu_mesh_to_gaussians.rs` is an older, partially different attempt; it references non-existent resources (`GpuPlanarGaussians`, `GpuMeshes`). Avoid using it; consider deleting or merging later.

## What to implement next (concrete)

- A. Make entity discovery robust:
	- When `MeshToGaussian` is added on any entity, search its descendants for the first entity with `Mesh3d` (or `Handle<Mesh>`). Use that mesh for conversion, and hide either the root or that mesh entity based on config.

- B. Spawn the cloud with the correct capacity:
	- Count triangles on CPU (`indices.len()/3`); create `PlanarGaussian3d` with that length; attach `PlanarGaussian3dHandle` + `CloudSettings`.

- C. Render-world compute path (one‑shot first):
	- Extract minimal descriptor (entity, cloud handle, transforms, counts).
	- In Prepare: create input SSBOs (positions, indices) and a small uniform buffer; create a bind group layout matching `assets/shaders/tri_to_splat.wgsl`.
	- Bind outputs by grabbing the GPU cloud from `RenderAssets<R::GpuPlanarType>` and using its storage buffers.
	- Dispatch compute exactly once when ready. Use a small RenderGraph `Node` inserted before sort/draw, or reuse an existing early Queue stage node.

- D. Realtime later:
	- Keep SSBOs resident and update only uniforms (and positions if animated). Optional: add a skinning pre‑pass.

## Quick references pulled from renderer (bevy_gaussian_splatting)

- Cloud rendering expects group(2) to be bound for draw; we don’t change that, we only write into its buffers.
- The renderer computes `CloudUniform` and sorts/draws each frame automatically once the cloud exists.

## Minimal acceptance for “working one‑shot”

- Mesh becomes hidden.
- A cloud is attached with `tri_count` points.
- Our compute runs once; buffers populated; gaussians visible in place of the mesh.

## Gotchas to avoid

- Don’t rely on Bevy’s internal GPU vertex buffer format; upload your own positions/indices SSBOs.
- Make sure the compute runs before the sort/draw (Prepare or early Queue), otherwise renderer will read zeros.
- If cloud size changes at runtime, you must recreate the `PlanarGaussian3d`; pre-allocate if needed and pass active_len in uniforms.
